from .fingerprint import Fingerprint
import numpy as np


class FingerprintWrapperGPAtom(Fingerprint):
    def __init__(
        self,
        fingerprint,
        reduce_dimensions=True,
        use_derivatives=True,
        **kwargs,
    ):
        """
        Fingerprint constructer class that convert atoms object into
        a fingerprint object with vector and derivatives.
        The fingerprint is generated by wrapping the fingerprint class
        from gpatom.

        Parameters:
            fingerprint: gpatom class.
                The fingerprint class instance from ase-gpatom.
            reduce_dimensions: bool
                Whether to reduce the fingerprint space if constrains are used.
            use_derivatives: bool
                Calculate and store derivatives of the fingerprint wrt.
                the cartesian coordinates.
        """
        super().__init__(
            fingerprint=fingerprint,
            reduce_dimensions=reduce_dimensions,
            use_derivatives=use_derivatives,
            **kwargs,
        )

    def update_arguments(
        self,
        fingerprint=None,
        reduce_dimensions=None,
        use_derivatives=None,
        **kwargs,
    ):
        """
        Update the class with its arguments.
        The existing arguments are used if they are not given.

        Parameters:
            fingerprint: gpatom class.
                The fingerprint class instance from ase-gpatom.
            reduce_dimensions: bool
                Whether to reduce the fingerprint space if constrains are used.
            use_derivatives: bool
                Calculate and store derivatives of the fingerprint wrt.
                the cartesian coordinates.

        Returns:
            self: The updated instance itself.
        """
        if fingerprint is not None:
            self.fingerprint = fingerprint
        if reduce_dimensions is not None:
            self.reduce_dimensions = reduce_dimensions
        if use_derivatives is not None:
            self.use_derivatives = use_derivatives
        return self

    def make_fingerprint(self, atoms, not_masked, masked, **kwargs):
        "The calculation of the gp-atom fingerprint"
        fp = self.fingerprint(
            atoms, calc_gradients=self.use_derivatives, **kwargs
        )
        vector = fp.vector.copy()
        if self.use_derivatives:
            derivative = fp.reduce_coord_gradients().copy()
            # enforced not_masked since it is not possible in ASE-GPATOM
            derivative = np.concatenate(derivative[not_masked], axis=1)
        else:
            derivative = None
        return vector, derivative

    def get_arguments(self):
        "Get the arguments of the class itself."
        # Get the arguments given to the class in the initialization
        arg_kwargs = dict(
            fingerprint=self.fingerprint,
            reduce_dimensions=self.reduce_dimensions,
            use_derivatives=self.use_derivatives,
        )
        # Get the constants made within the class
        constant_kwargs = dict()
        # Get the objects made within the class
        object_kwargs = dict()
        return arg_kwargs, constant_kwargs, object_kwargs


class FingerprintWrapperDScribe(Fingerprint):
    def __init__(
        self,
        fingerprint,
        reduce_dimensions=True,
        use_derivatives=True,
        fingerprint_kwargs={},
        **kwargs,
    ):
        """
        Fingerprint constructer class that convert atoms object into
        a fingerprint object with vector and derivatives.
        The fingerprint is generated by wrapping the fingerprint class
        from dscribe (>=2.1).

        Parameters:
            fingerprint: dscribe class instance (>=2.1).
                The fingerprint class instance from dscribe.
            reduce_dimensions: bool
                Whether to reduce the fingerprint space if constrains are used.
            use_derivatives: bool
                Calculate and store derivatives of the fingerprint wrt.
                the cartesian coordinates.
            fingerprint_kwargs: dict
                Kwargs for the fingerprint function call.
        """
        super().__init__(
            fingerprint=fingerprint,
            reduce_dimensions=reduce_dimensions,
            use_derivatives=use_derivatives,
            fingerprint_kwargs=fingerprint_kwargs,
            **kwargs,
        )

    def update_arguments(
        self,
        fingerprint=None,
        reduce_dimensions=None,
        use_derivatives=None,
        fingerprint_kwargs=None,
        **kwargs,
    ):
        """
        Update the class with its arguments.
        The existing arguments are used if they are not given.

        Parameters:
            fingerprint: dscribe class instance (>=2.1).
                The fingerprint class instance from dscribe.
            reduce_dimensions: bool
                Whether to reduce the fingerprint space if constrains are used.
            use_derivatives: bool
                Calculate and store derivatives of the fingerprint wrt.
                the cartesian coordinates.
            fingerprint_kwargs: dict
                Kwargs for the fingerprint function call.

        Returns:
            self: The updated instance itself.
        """
        if fingerprint is not None:
            self.fingerprint = fingerprint
        if reduce_dimensions is not None:
            self.reduce_dimensions = reduce_dimensions
        if use_derivatives is not None:
            self.use_derivatives = use_derivatives
        if fingerprint_kwargs is not None:
            self.fingerprint_kwargs = fingerprint_kwargs.copy()
        return self

    def make_fingerprint(self, atoms, not_masked, masked, **kwargs):
        "The calculation of the dscribe fingerprint"
        if self.use_derivatives:
            derivative, vector = self.fingerprint.derivatives(
                atoms,
                include=not_masked,
                return_descriptor=True,
                **self.fingerprint_kwargs,
            )
            if len(derivative.shape) == 4:
                derivative = np.transpose(derivative, (0, 3, 1, 2))
            else:
                derivative = np.transpose(derivative, (2, 0, 1))
            derivative = derivative.reshape(-1, len(not_masked) * 3)
        else:
            vector = self.fingerprint.create(atoms, **self.fingerprint_kwargs)
            derivative = None
        return vector.reshape(-1), derivative

    def get_arguments(self):
        "Get the arguments of the class itself."
        # Get the arguments given to the class in the initialization
        arg_kwargs = dict(
            fingerprint=self.fingerprint,
            reduce_dimensions=self.reduce_dimensions,
            use_derivatives=self.use_derivatives,
            fingerprint_kwargs=self.fingerprint_kwargs,
        )
        # Get the constants made within the class
        constant_kwargs = dict()
        # Get the objects made within the class
        object_kwargs = dict()
        return arg_kwargs, constant_kwargs, object_kwargs
